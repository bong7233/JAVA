# JPA (Java Persistence API)
스프링은 DB와 데이터를 주고받는 까다로운 규칙이 있다.  

그래서 서버가 DB와 통신하려면 스프링의 규칙도 지키고 SQL도 작성해야하는 번거로움이 있다.

가장 큰 문제는 객체지향적인 자바코드를 SQL로 변환하는 것이다.  

DB의 데이터는 객체라는 개념이 없이 테이블형태로 들어가 있기 때문에 자바에서 객체를 다루듯 데이터를 조회,수정,입력 한다면 DB에서 원하는 결과를 얻기 힘들다.  

이때 서버와 DB사이에서 통역역할을 하는것이 JPA다.  

서버가 DB와 연결할때 개발자가 작성한 자바 코드를 JPA가 자동으로 SQL로 바꿔서 DB에 보내준다.  

때문에 개발자는 하나의 코드만 작성해도 DB가 변경되어도 다시 쿼리문을 작성할 필요가 없어진다.  

<br>

## 영속성 (Persistence)
객체지향과 DB의 차이를 극복하기 위해 영속성 개념을 이용한다.  
```
차이점이 무엇이길래 극복하는걸까?

예를들어

DB에 들어있는 Bong 이라는 데이터를 수정하려면 
DB에서 Bong을 조회하고 수정해서 다시 넣는다.
(or 지우고 새로운 데이터를 넣는다)

하지만 JPA를 사용하면 꺼낼 필요없이
DB에서 데이터를 찾고 수정하기만 하면 데이터가 바로 변경된다.

마치 Array에서 값을 꺼내지 않고 바로 수정할 수 있는것과 같은
효과를 적용할 수 있는것이다.
```

이렇게 **"객체형태가 아닌 DB의 데이터를 마치 객체 다루듯"** 

할 수 있는 이유가 JPA의 영속성 때문이다.  

- 영속 컨테스트(entityManager)  
영속 컨테스트 내부에 1차 캐시가 존재해서 데이터를 임시 저장하지만, 한 번의 트랜잭션에서만 유지되는 아주 짧은 캐시라서 성능에는 큰 영향을 미치지 않는다.  

- 영속 엔티티의 동일성 보장  
같은 트랜잭션 안에서 캐시가 유지되기 때문에 한 트랜잭션에서 이미 저장된 객체를 다시 조회하거나 사용할 때 같은 객체를 사용하는 것과 같다. (자바에서 같은 참조값을 가지는 두 변수는 결국 같은 값을 가리키는것과 동일하다)   

이 동일성 때문에 동일한 데이터(객체)를 여러번 조회하더라도 commit 하기 전에는 1차캐시 내부에 저장된 동일한 객체를 계속 사용한다.  

즉, commit 하기 전에는 SQL을 DB에 보내지 않고 commit 까지 기다리기 때문에 "버퍼링" 효과가 있다. (버퍼링은 평소에 동영상 버퍼링 걸렸다,영상이 멈췄다는 의미로 사용된다.)    

## 그럼 버퍼링을 사용하는 이유가 무엇일까?  

프로그래밍에서는 작업을 여러번 하는것 보다 버퍼라는 단위로 묶어서 한번에 보내는것이 효율적이다.  
```
DB에 Bong 이라는 데이터를 넣고싶다면
B 보내고 o 보내고 n 보내고 g 보낸다

만약 실수로 g 대신 m을 보냈다면?
BD에서 m을 지우고 g를 다시넣어야 한다.
이것만 해도 벌써 6번의 쿼리를 보낸다.

하지만 버퍼라는 임시공간에 Bong를 저장해두고 한번에 DB에 보낸다면
실수로 g 대신 n을 적었어도 임시공간에서 m만 수정하고  
한번의 쿼리로 DB에 저장할 수 있다.
```


